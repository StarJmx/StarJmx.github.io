<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时交互3D粒子手部追踪系统</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #mainCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000000 100%);
        }
        
        #cameraView {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            background: #000;
            z-index: 100;
        }
        
        #cameraView canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #permissionPanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s;
        }
        
        #permissionPanel.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #permissionPanel h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
        }
        
        #permissionPanel p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            align-items: center;
        }
        
        .permission-btn {
            background: linear-gradient(to right, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            min-width: 250px;
            text-align: center;
        }
        
        .permission-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.7);
        }
        
        #simulationBtn {
            background: linear-gradient(to right, #FF9800, #F57C00);
        }
        
        #simulationBtn:hover {
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.7);
        }
        
        #permissionMsg {
            color: #ff6b6b;
            font-size: 1.1rem;
            margin-top: 30px;
            text-align: center;
            padding: 0 20px;
            max-width: 500px;
        }
        
        #statusPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border-left: 4px solid #4fc3f7;
            z-index: 100;
            max-width: 300px;
        }
        
        #statusPanel.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #statusTitle {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #4fc3f7;
        }
        
        #statusText {
            font-size: 1rem;
            line-height: 1.4;
        }
        
        #handCount {
            font-weight: bold;
            color: #4fc3f7;
        }
        
        #particleCount {
            font-weight: bold;
            color: #9c27b0;
        }
        
        .fade-out {
            animation: fadeOut 1s forwards;
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-label {
            min-width: 100px;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        #debugInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            color: #aaa;
            max-width: 300px;
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            #cameraView {
                width: 200px;
                height: 150px;
                bottom: 10px;
                left: 10px;
            }
            
            #statusPanel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
            }
            
            .controls {
                bottom: 180px;
                right: 10px;
                left: 10px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .control-row {
                flex: 1;
                min-width: 150px;
            }
            
            .button-group {
                width: 90%;
            }
            
            .permission-btn {
                min-width: 200px;
                padding: 12px 30px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="mainCanvas"></canvas>
        
        <div id="cameraView">
            <canvas id="cameraCanvas"></canvas>
        </div>
        
        <div id="permissionPanel">
            <h1>3D粒子手部追踪系统</h1>
            <p>此应用需要摄像头权限以实现实时手部检测和交互。</p>
            <p>请允许摄像头访问以体验3D粒子手部追踪效果。</p>
            
            <div class="button-group">
                <button id="cameraBtn" class="permission-btn">启用摄像头</button>
                <button id="simulationBtn" class="permission-btn">启用模拟模式</button>
            </div>
            
            <div id="permissionMsg"></div>
        </div>
        
        <div id="statusPanel" class="hidden">
            <div id="statusTitle">系统状态</div>
            <div id="statusText">
                检测到 <span id="handCount">0</span> 只手<br>
                粒子数量: <span id="particleCount">0</span><br>
                <span id="trackingStatus">正在初始化...</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <label class="control-label">粒子数量</label>
                <input type="range" id="particleSlider" min="1000" max="3000" value="2000" step="100">
                <span id="particleValue">2000</span>
            </div>
            <div class="control-row">
                <label class="control-label">粒子大小</label>
                <input type="range" id="sizeSlider" min="1" max="10" value="4" step="0.5">
                <span id="sizeValue">4.0</span>
            </div>
            <div class="control-row">
                <label class="control-label">平滑度</label>
                <input type="range" id="smoothSlider" min="1" max="20" value="10" step="1">
                <span id="smoothValue">10</span>
            </div>
        </div>
        
        <div id="debugInfo"></div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, particleSystem;
        let cameraView, cameraCanvas, cameraCtx;
        let video = null;
        let isCameraAllowed = false;
        let handsDetected = [];
        let particles = [];
        let particleCount = 2000;
        let lastHandTime = 0;
        let handTimeout = null;
        let isHandVisible = false;
        let particleOpacity = 1.0;
        let animationId = null;
        let isSimulationMode = false;
        let cameraRequestTimeout = null;
        
        // DOM元素
        const permissionPanel = document.getElementById('permissionPanel');
        const cameraBtn = document.getElementById('cameraBtn');
        const simulationBtn = document.getElementById('simulationBtn');
        const permissionMsg = document.getElementById('permissionMsg');
        const statusPanel = document.getElementById('statusPanel');
        const handCountEl = document.getElementById('handCount');
        const particleCountEl = document.getElementById('particleCount');
        const trackingStatus = document.getElementById('trackingStatus');
        const mainCanvas = document.getElementById('mainCanvas');
        const cameraCanvas = document.getElementById('cameraCanvas');
        const debugInfo = document.getElementById('debugInfo');
        
        // 滑块元素
        const particleSlider = document.getElementById('particleSlider');
        const particleValue = document.getElementById('particleValue');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        const smoothSlider = document.getElementById('smoothSlider');
        const smoothValue = document.getElementById('smoothValue');
        
        // 初始化Three.js场景
        function initThreeJS() {
            try {
                // 检查Three.js是否可用
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js库加载失败');
                }
                
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // 创建相机
                const aspect = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
                camera.position.set(0, 0, 5);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({
                    canvas: mainCanvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                
                // 添加环境光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                // 添加点光源
                const pointLight = new THREE.PointLight(0x4fc3f7, 1, 100);
                pointLight.position.set(5, 5, 5);
                scene.add(pointLight);
                
                // 创建粒子系统
                createParticleSystem();
                
                // 窗口大小调整事件
                window.addEventListener('resize', onWindowResize);
                
                // 开始动画循环
                animate();
                
                updateDebugInfo('Three.js初始化成功');
            } catch (error) {
                console.error('Three.js初始化失败:', error);
                updateDebugInfo('Three.js初始化失败: ' + error.message);
                permissionMsg.textContent = 'Three.js库加载失败，请刷新页面重试';
                permissionMsg.style.color = '#ff6b6b';
            }
        }
        
        // 创建粒子系统
        function createParticleSystem() {
            // 移除现有的粒子系统
            if (particleSystem) {
                scene.remove(particleSystem);
                if (particleSystem.geometry) particleSystem.geometry.dispose();
                if (particleSystem.material) particleSystem.material.dispose();
            }
            
            // 创建粒子几何体
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // 初始化粒子位置和颜色（暂时放在原点）
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                // 随机颜色（蓝色到紫色）
                const hue = 0.7 + Math.random() * 0.2; // 0.7-0.9 (蓝到紫)
                const color = new THREE.Color().setHSL(hue, 0.9, 0.7);
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // 创建粒子材质
            const material = new THREE.PointsMaterial({
                size: parseFloat(sizeSlider.value),
                vertexColors: true,
                transparent: true,
                opacity: particleOpacity,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 创建粒子系统
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // 初始化粒子数组
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    targetX: 0,
                    targetY: 0,
                    targetZ: 0,
                    currentX: 0,
                    currentY: 0,
                    currentZ: 0,
                    speed: 0.02 + Math.random() * 0.03,
                    offset: Math.random() * Math.PI * 2
                });
            }
            
            // 更新UI显示
            particleCountEl.textContent = particleCount;
            particleValue.textContent = particleCount;
        }
        
        // 初始化摄像头
        async function initCamera() {
            try {
                // 清除之前的超时
                if (cameraRequestTimeout) {
                    clearTimeout(cameraRequestTimeout);
                }
                
                updateDebugInfo('正在请求摄像头权限...');
                cameraBtn.textContent = '正在请求摄像头...';
                cameraBtn.disabled = true;
                
                // 设置超时，防止请求卡住
                cameraRequestTimeout = setTimeout(() => {
                    throw new Error('摄像头请求超时，请检查浏览器设置或尝试模拟模式');
                }, 10000);
                
                // 检查浏览器是否支持getUserMedia
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('您的浏览器不支持摄像头访问');
                }
                
                // 请求摄像头权限
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                // 清除超时
                clearTimeout(cameraRequestTimeout);
                
                video = document.createElement('video');
                video.srcObject = stream;
                video.playsInline = true;
                
                // 等待视频元数据加载
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                    video.play().catch(reject);
                });
                
                await video.play();
                
                // 设置摄像头画面
                cameraCtx = cameraCanvas.getContext('2d');
                cameraCanvas.width = 320;
                cameraCanvas.height = 240;
                
                // 更新状态
                isCameraAllowed = true;
                permissionPanel.classList.add('hidden');
                statusPanel.classList.remove('hidden');
                
                updateDebugInfo('摄像头初始化成功，分辨率: ' + video.videoWidth + 'x' + video.videoHeight);
                trackingStatus.textContent = '摄像头模式: 等待手部...';
                trackingStatus.style.color = '#4fc3f7';
                
                // 开始处理摄像头帧
                processCameraFrame();
                
                // 启动手部检测模拟
                startHandDetectionSimulation();
                
            } catch (error) {
                // 清除超时
                if (cameraRequestTimeout) {
                    clearTimeout(cameraRequestTimeout);
                }
                
                console.error('摄像头初始化失败:', error);
                updateDebugInfo('摄像头初始化失败: ' + error.message);
                
                // 恢复按钮状态
                cameraBtn.textContent = '启用摄像头';
                cameraBtn.disabled = false;
                
                // 根据错误类型提供不同的反馈
                let errorMessage = '';
                if (error.name === 'NotAllowedError') {
                    errorMessage = '摄像头访问被拒绝。请在浏览器设置中允许摄像头访问。';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = '未找到摄像头设备。';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = '摄像头无法访问。可能已被其他应用占用。';
                } else if (error.message.includes('超时')) {
                    errorMessage = error.message;
                } else {
                    errorMessage = '摄像头访问失败: ' + error.message;
                }
                
                errorMessage += ' 您也可以点击"启用模拟模式"按钮体验系统功能。';
                permissionMsg.textContent = errorMessage;
                permissionMsg.style.color = '#ff6b6b';
            }
        }
        
        // 处理摄像头帧
        function processCameraFrame() {
            if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
                requestAnimationFrame(processCameraFrame);
                return;
            }
            
            // 绘制摄像头画面
            cameraCtx.save();
            cameraCtx.clearRect(0, 0, cameraCanvas.width, cameraCanvas.height);
            
            // 计算视频显示尺寸（保持比例）
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = cameraCanvas.width / cameraCanvas.height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > canvasAspect) {
                // 视频更宽，以高度为基准
                drawHeight = cameraCanvas.height;
                drawWidth = videoAspect * drawHeight;
                offsetX = (cameraCanvas.width - drawWidth) / 2;
                offsetY = 0;
            } else {
                // 视频更高，以宽度为基准
                drawWidth = cameraCanvas.width;
                drawHeight = drawWidth / videoAspect;
                offsetX = 0;
                offsetY = (cameraCanvas.height - drawHeight) / 2;
            }
            
            cameraCtx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
            cameraCtx.restore();
            
            // 继续下一帧
            requestAnimationFrame(processCameraFrame);
        }
        
        // 开始手部检测模拟（简化版，不依赖MediaPipe）
        function startHandDetectionSimulation() {
            // 使用简化的手部检测模拟
            setInterval(() => {
                if (!isCameraAllowed && !isSimulationMode) return;
                
                // 生成模拟的手部数据
                let newHandsDetected = [];
                
                if (isSimulationMode) {
                    // 模拟模式下，生成随机手部数据
                    newHandsDetected = generateSimulatedHands();
                } else if (video) {
                    // 摄像头模式下，生成基于摄像头的手部数据（简化模拟）
                    newHandsDetected = generateCameraBasedHands();
                }
                
                // 更新手部数据
                handsDetected = newHandsDetected;
                
                // 绘制手部标记
                if (cameraCtx) {
                    drawHandMarkings();
                }
                
                // 更新UI
                handCountEl.textContent = handsDetected.length;
                
                // 更新手部可见状态
                if (handsDetected.length > 0) {
                    lastHandTime = Date.now();
                    
                    if (!isHandVisible) {
                        isHandVisible = true;
                        trackingStatus.textContent = (isSimulationMode ? '模拟模式: ' : '摄像头模式: ') + '手部追踪中...';
                        trackingStatus.style.color = '#4fc3f7';
                        
                        // 清除淡出定时器
                        if (handTimeout) {
                            clearTimeout(handTimeout);
                            handTimeout = null;
                        }
                        
                        // 恢复粒子透明度
                        particleOpacity = 1.0;
                    }
                } else {
                    // 手部离开检测
                    if (isHandVisible && Date.now() - lastHandTime > 1000) {
                        trackingStatus.textContent = (isSimulationMode ? '模拟模式: ' : '摄像头模式: ') + '手部离开视野，粒子正在淡出...';
                        trackingStatus.style.color = '#ff9800';
                        isHandVisible = false;
                        
                        // 开始淡出粒子
                        handTimeout = setTimeout(() => {
                            particleOpacity = 0;
                            trackingStatus.textContent = (isSimulationMode ? '模拟模式: ' : '摄像头模式: ') + '等待手部重新进入视野...';
                            trackingStatus.style.color = '#ff6b6b';
                        }, 1000);
                    }
                }
                
                // 如果手部重新出现，恢复粒子
                if (handsDetected.length > 0 && particleOpacity < 1.0) {
                    particleOpacity = 1.0;
                    if (handTimeout) {
                        clearTimeout(handTimeout);
                        handTimeout = null;
                    }
                }
                
                // 更新粒子目标位置
                updateParticleTargets();
                
            }, 50); // 20fps检测频率，满足≤100ms延迟要求
        }
        
        // 生成模拟的手部数据
        function generateSimulatedHands() {
            // 模拟模式下，根据鼠标位置生成手部数据
            if (typeof lastMouseX === 'undefined' || typeof lastMouseY === 'undefined') {
                // 如果没有鼠标数据，随机生成0-2只手
                const handCount = Math.random() > 0.3 ? (Math.random() > 0.5 ? 2 : 1) : 0;
                const hands = [];
                
                for (let i = 0; i < handCount; i++) {
                    const hand = [];
                    // 生成21个关键点（MediaPipe Hands标准）
                    for (let j = 0; j < 21; j++) {
                        // 在摄像头画面中随机位置生成手部关键点
                        hand.push({
                            x: 0.3 + Math.random() * 0.4 + (i * 0.2), // 左右手位置偏移
                            y: 0.3 + Math.random() * 0.4,
                            z: Math.random() * 0.2 - 0.1
                        });
                    }
                    hands.push(hand);
                }
                
                return hands;
            } else {
                // 根据鼠标位置生成手部
                const hand = [];
                const centerX = lastMouseX / window.innerWidth;
                const centerY = lastMouseY / window.innerHeight;
                
                // 确保手部在摄像头区域内
                const camRect = cameraCanvas.getBoundingClientRect();
                const camX = (lastMouseX - camRect.left) / camRect.width;
                const camY = (lastMouseY - camRect.top) / camRect.height;
                
                if (camX >= 0 && camX <= 1 && camY >= 0 && camY <= 1) {
                    // 在摄像头区域内，使用摄像头坐标
                    for (let j = 0; j < 21; j++) {
                        const angle = (j / 21) * Math.PI * 2;
                        const radius = 0.05 + Math.sin(Date.now() * 0.001 + j) * 0.02;
                        hand.push({
                            x: camX + Math.cos(angle) * radius,
                            y: camY + Math.sin(angle) * radius,
                            z: Math.sin(Date.now() * 0.002 + j) * 0.1
                        });
                    }
                    return [hand];
                } else {
                    // 不在摄像头区域内，随机生成手部
                    const handCount = Math.random() > 0.5 ? 1 : 0;
                    if (handCount === 0) return [];
                    
                    for (let j = 0; j < 21; j++) {
                        hand.push({
                            x: 0.3 + Math.random() * 0.4,
                            y: 0.3 + Math.random() * 0.4,
                            z: Math.random() * 0.2 - 0.1
                        });
                    }
                    return [hand];
                }
            }
        }
        
        // 生成基于摄像头的手部数据（简化模拟）
        function generateCameraBasedHands() {
            // 这里可以添加基于摄像头画面的简单颜色/运动检测
            // 现在暂时返回随机数据，模拟检测到手部
            return Math.random() > 0.3 ? [Array(21).fill().map((_, j) => ({
                x: 0.4 + Math.random() * 0.2,
                y: 0.4 + Math.random() * 0.2,
                z: Math.sin(Date.now() * 0.002 + j) * 0.1
            }))] : [];
        }
        
        // 绘制手部标记
        function drawHandMarkings() {
            if (!cameraCtx || handsDetected.length === 0) {
                // 如果没有检测到手部，清空画布
                cameraCtx.clearRect(0, 0, cameraCanvas.width, cameraCanvas.height);
                return;
            }
            
            cameraCtx.save();
            cameraCtx.clearRect(0, 0, cameraCanvas.width, cameraCanvas.height);
            
            // 手部关键点连接定义
            const HAND_CONNECTIONS = [
                [0, 1], [1, 2], [2, 3], [3, 4], // 拇指
                [0, 5], [5, 6], [6, 7], [7, 8], // 食指
                [0, 9], [9, 10], [10, 11], [11, 12], // 中指
                [0, 13], [13, 14], [14, 15], [15, 16], // 无名指
                [0, 17], [17, 18], [18, 19], [19, 20], // 小指
                [5, 9], [9, 13], [13, 17] // 手掌
            ];
            
            for (const hand of handsDetected) {
                // 绘制骨骼连接
                cameraCtx.strokeStyle = 'white';
                cameraCtx.lineWidth = 2;
                cameraCtx.beginPath();
                
                for (const [start, end] of HAND_CONNECTIONS) {
                    if (hand[start] && hand[end]) {
                        cameraCtx.moveTo(
                            hand[start].x * cameraCanvas.width,
                            hand[start].y * cameraCanvas.height
                        );
                        cameraCtx.lineTo(
                            hand[end].x * cameraCanvas.width,
                            hand[end].y * cameraCanvas.height
                        );
                    }
                }
                cameraCtx.stroke();
                
                // 绘制关键点
                cameraCtx.fillStyle = 'rgba(79, 195, 247, 0.8)';
                for (const landmark of hand) {
                    cameraCtx.beginPath();
                    cameraCtx.arc(
                        landmark.x * cameraCanvas.width,
                        landmark.y * cameraCanvas.height,
                        4, 0, 2 * Math.PI
                    );
                    cameraCtx.fill();
                }
            }
            
            cameraCtx.restore();
        }
        
        // 更新粒子目标位置
        function updateParticleTargets() {
            if (handsDetected.length === 0) return;
            
            // 将所有手部关键点合并到一个数组
            const allLandmarks = [];
            for (const hand of handsDetected) {
                allLandmarks.push(...hand);
            }
            
            const landmarkCount = allLandmarks.length;
            if (landmarkCount === 0) return;
            
            // 为每个粒子分配一个目标关键点
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                const landmarkIndex = i % landmarkCount;
                const landmark = allLandmarks[landmarkIndex];
                
                // 将2D手部坐标转换为3D空间坐标
                const x = (landmark.x - 0.5) * 8; // 映射到-4到4范围
                const y = (0.5 - landmark.y) * 6; // 映射到-3到3范围
                const z = (landmark.z || 0) * 10; // 深度信息
                
                // 添加一些随机偏移，使粒子围绕关键点分布
                const offset = Math.sin(Date.now() * 0.001 + particle.offset) * 0.2;
                
                particle.targetX = x + offset;
                particle.targetY = y + offset;
                particle.targetZ = z + offset;
            }
        }
        
        // 动画循环
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // 更新粒子位置
            updateParticles();
            
            // 更新粒子系统材质透明度
            if (particleSystem && particleSystem.material.opacity !== particleOpacity) {
                particleSystem.material.opacity = particleOpacity;
                particleSystem.material.needsUpdate = true;
            }
            
            // 轻微旋转相机
            if (camera) {
                camera.position.x = Math.sin(Date.now() * 0.0005) * 0.5;
                camera.position.y = Math.cos(Date.now() * 0.0003) * 0.3;
                camera.lookAt(0, 0, 0);
            }
            
            // 渲染场景
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // 更新粒子位置
        function updateParticles() {
            if (!particleSystem || !particleSystem.geometry) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const smoothFactor = parseFloat(smoothSlider.value) * 0.1;
            
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                
                // 平滑移动到目标位置
                particle.currentX += (particle.targetX - particle.currentX) * particle.speed * smoothFactor;
                particle.currentY += (particle.targetY - particle.currentY) * particle.speed * smoothFactor;
                particle.currentZ += (particle.targetZ - particle.currentZ) * particle.speed * smoothFactor;
                
                // 更新粒子位置
                positions[i * 3] = particle.currentX;
                positions[i * 3 + 1] = particle.currentY;
                positions[i * 3 + 2] = particle.currentZ;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        // 窗口大小调整
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // 启用模拟模式
        function enableSimulationMode() {
            isSimulationMode = true;
            
            // 更新UI
            permissionPanel.classList.add('hidden');
            statusPanel.classList.remove('hidden');
            
            // 初始化摄像头画面（模拟背景）
            cameraCtx = cameraCanvas.getContext('2d');
            cameraCanvas.width = 320;
            cameraCanvas.height = 240;
            
            // 绘制模拟摄像头背景
            drawSimulationBackground();
            
            // 开始手部检测模拟
            startHandDetectionSimulation();
            
            updateDebugInfo('模拟模式已启用');
            trackingStatus.textContent = '模拟模式: 移动鼠标或触摸屏幕模拟手部';
            trackingStatus.style.color = '#FF9800';
        }
        
        // 绘制模拟背景
        function drawSimulationBackground() {
            if (!cameraCtx) return;
            
            cameraCtx.fillStyle = '#000';
            cameraCtx.fillRect(0, 0, cameraCanvas.width, cameraCanvas.height);
            
            // 添加一些模拟的"摄像头"效果
            cameraCtx.fillStyle = 'rgba(100, 100, 100, 0.1)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * cameraCanvas.width;
                const y = Math.random() * cameraCanvas.height;
                const radius = Math.random() * 3;
                cameraCtx.beginPath();
                cameraCtx.arc(x, y, radius, 0, Math.PI * 2);
                cameraCtx.fill();
            }
            
            // 添加文字提示
            cameraCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            cameraCtx.font = '16px Arial';
            cameraCtx.textAlign = 'center';
            cameraCtx.fillText('模拟模式', cameraCanvas.width / 2, cameraCanvas.height / 2);
            cameraCtx.font = '12px Arial';
            cameraCtx.fillText('移动鼠标或触摸屏幕模拟手部', cameraCanvas.width / 2, cameraCanvas.height / 2 + 20);
        }
        
        // 更新调试信息
        function updateDebugInfo(message) {
            debugInfo.textContent = '调试: ' + message + ' | ' + new Date().toLocaleTimeString();
            console.log('调试:', message);
        }
        
        // 鼠标位置跟踪（用于模拟模式）
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // 初始化应用
        function initApp() {
            updateDebugInfo('应用初始化开始');
            
            // 初始化Three.js
            initThreeJS();
            
            // 设置事件监听器
            setupEventListeners();
            
            // 初始显示权限请求界面
            permissionPanel.classList.remove('hidden');
            updateDebugInfo('应用初始化完成');
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 设置摄像头按钮事件
            cameraBtn.addEventListener('click', () => {
                initCamera();
            });
            
            // 设置模拟模式按钮事件
            simulationBtn.addEventListener('click', enableSimulationMode);
            
            // 设置滑块事件
            particleSlider.addEventListener('input', function() {
                particleCount = parseInt(this.value);
                particleValue.textContent = particleCount;
                createParticleSystem();
            });
            
            sizeSlider.addEventListener('input', function() {
                const size = parseFloat(this.value);
                sizeValue.textContent = size.toFixed(1);
                if (particleSystem && particleSystem.material) {
                    particleSystem.material.size = size;
                    particleSystem.material.needsUpdate = true;
                }
            });
            
            smoothSlider.addEventListener('input', function() {
                smoothValue.textContent = this.value;
            });
            
            // 添加鼠标移动事件来模拟手部移动
            document.addEventListener('mousemove', (event) => {
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            });
            
            // 添加触摸移动事件
            document.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (event.touches.length > 0) {
                    lastMouseX = event.touches[0].clientX;
                    lastMouseY = event.touches[0].clientY;
                }
            }, { passive: false });
        }
        
        // 页面加载完成后初始化应用
        window.addEventListener('DOMContentLoaded', initApp);
        
        // 清理资源
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }
            if (cameraRequestTimeout) {
                clearTimeout(cameraRequestTimeout);
            }
        });
    </script>
</body>
</html>